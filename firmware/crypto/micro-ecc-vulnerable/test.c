#include <stdio.h>
#include <stdlib.h>
#include <uECC.c>

int rng_fn(uint8_t *dest, unsigned int size) {
  // chosen by fair dice roll.
  // guaranteed to be random.
  // https://xkcd.com/221/
  for (unsigned int i = 0; i < size; i++) {
    dest[i] = 42;
  }
  return 1;
}

const static uint8_t PUBKEY[uECC_MAX_WORDS * 2 * sizeof(uECC_word_t)] = {
    0xff, 0x67, 0xf1, 0x57, 0xba, 0x51, 0xa2, 0x54, 0x3a, 0x00, 0x7f,
    0x89, 0x67, 0xab, 0xda, 0xe2, 0xe2, 0x5f, 0xb4, 0x69, 0x84, 0x39,
    0x43, 0x3b, 0x97, 0x85, 0x39, 0xce, 0x70, 0x3e, 0xfb, 0xf9, 0x54,
    0x02, 0x56, 0xBD, 0x83, 0x02, 0x6E, 0x3B, 0xCD, 0x0C, 0x1A, 0x46,
    0x6A, 0x94, 0x2C, 0xA5, 0x2E, 0x0D, 0x03, 0x8F, 0x7B, 0x93, 0x94,
    0xB1, 0x69, 0xC5, 0xB3, 0x50, 0x86, 0x18, 0xB4, 0x6D // No leading 0s in mul scalar, works

    // 0xFD, 0x86, 0x69, 0xBD, 0x66, 0xF4, 0x50, 0xB3, 0x54, 0xCC, 0x63, 0xE2,
    // 0xB2, 0x5B, 0xD0, 0x9E,
    // 0x0F, 0xC0, 0xC1, 0xB1, 0xFC, 0xE8, 0x97, 0x9A, 0xE5, 0x89, 0xC1, 0xF3,
    // 0xD0, 0xF1, 0xF5, 0xF3,
    // 0x8F, 0xEF, 0x12, 0x75, 0x8A, 0x67, 0x99, 0x18, 0xCA, 0x0B, 0xB7, 0xC2,
    // 0x7C, 0xB4, 0xD1, 0xD0,
    // 0x7E, 0xAF, 0xE2, 0xA4, 0x9C, 0xC8, 0x7D, 0xDC, 0x2B, 0xCE, 0xF0, 0x49,
    // 0x99, 0xAB, 0xCE, 0xD1 // Leading 0s in mul scalar, doesnt work

    // 0x2e, 0x2e, 0xde, 0x96, 0xdb, 0x4b, 0x6e, 0x02, 0x9c, 0xb7, 0x99,
    // 0x5b, 0x8d, 0x0c, 0x61, 0x33, 0x9b, 0x34, 0x6b, 0xe1, 0xce, 0x48,
    // 0x4d, 0xa3, 0x3a, 0xcd, 0x24, 0xc6, 0xe0, 0xdb, 0x1a, 0x4c, 0xe6,
    // 0x5c, 0xad, 0xe6, 0x61, 0x43, 0xf5, 0xd7, 0x95, 0xbb, 0x66, 0x79,
    // 0x54, 0xff, 0x3b, 0xb6, 0x2c, 0x77, 0xaf, 0x60, 0x2f, 0x41, 0xeb,
    // 0xcf, 0x82, 0x9b, 0x96, 0xae, 0xbf, 0xfe, 0x4c, 0x49
  };

const static uint8_t PRIVKEY[uECC_MAX_WORDS * sizeof(uECC_word_t)] = {
    0x48, 0x77, 0x53, 0x62, 0xB1, 0x41, 0xBC, 0x10, 0x36, 0xFA, 0xDE,
    0x0F, 0xE5, 0xB8, 0xD5, 0xB6, 0x40, 0xAC, 0x23, 0xFE, 0x16, 0x08,
    0xF8, 0x1A, 0x13, 0x53, 0x1E, 0x85, 0xFD, 0xF0, 0x6C, 0xCF

    // 0x48, 0x77, 0x53, 0x62, 0xB1, 0x41, 0xBC, 0x10, 0x36, 0xFA, 0xDE,
    // 0x0F, 0xE5, 0xB8, 0xD5, 0xB6, 0x40, 0xAC, 0x23, 0xFE, 0x16, 0x08,
    // 0xF8, 0x1A, 0x13, 0x53, 0x1E, 0x85, 0xFD, 0xF0, 0x6C, 0x02
};

const static uint8_t MESSAGE[] = {
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1};

const static uint8_t SIGNATURE[] = {
    12,  144, 29,  66,  60,  131, 28,  168, 94,  39,  199, 60,  38,
    59,  161, 50,  114, 27,  185, 215, 168, 76,  79,  3,   128, 178,
    166, 117, 111, 214, 1,   51,  101, 170, 201, 151, 253, 137, 38,
    230, 37,  162, 188, 92,  148, 252, 130, 52,  75,  198, 134, 147,
    97,  85,  157, 114, 162, 213, 85,  214, 8,   153, 129, 189};

// uECC_word_t = 4
// uECC_MAX_WORDS = 8
// curve->n_words = 8

int main() {
  uECC_set_rng(rng_fn);
  const struct uECC_Curve_t *curve;
  curve = uECC_secp256r1();
  uint8_t public_key[sizeof(PUBKEY)];

  uECC_compute_public_key(PRIVKEY, public_key, curve);

  if (uECC_vli_equal((uECC_word_t *)PUBKEY, (uECC_word_t *)public_key,
                     sizeof(PUBKEY) / sizeof(uECC_word_t)) == 1) {
    printf("Equal \n");
  } else {
    printf("Not equal\n");
    // for (int i = 0; i < sizeof(PUBKEY); i++) {
    //   printf("%d %d\n", PUBKEY[i], public_key[i]);
    // }
  }
  uint8_t signature[64];
  if (!uECC_sign(PRIVKEY, MESSAGE, sizeof(MESSAGE), signature, curve)) {
    printf("error while signing\n");
  }

  if (uECC_vli_equal((uECC_word_t *)SIGNATURE, (uECC_word_t *)signature,
                     sizeof(PUBKEY) / sizeof(uECC_word_t))) {
    printf("Signatures equal\n");
  } else {
    printf("Signatures NOT equal\n");
  }
  return 0;
}